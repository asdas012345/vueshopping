<!--
 * @Descripttion: 
 * @version: 
 * @Author: lujj
 * @Date: 2020-08-17 10:46:20
 * @LastEditors: sueRimn
 * @LastEditTime: 2020-09-14 19:15:05
-->
# vueshopping

## 项目介绍
url:http://vue.lujiajing.top/2007
我做的是一个仿京东的一个vue项目，主要用的技术栈是vue全家桶，包括vue-router，vuex状态管理，axios服务端通讯，vue-cli4.5脚手架，vant组件库，阿里inconfont图标库，通过vue create myvueapp创建项目，然后自定义选择配置项，选择vue的版本，路由，状态管理，node-sass样式处理器，校验代码格式和测试工具。

Vue框架主要用的是单文件组件的模式开发的，Vue自定义了一种.vue文件，可以把html,css,js 写到一个文件中，从而实现了对一个组件的封装。它的优点是代码集中，便于开发，管理和维护，可复用性高，直接将vue文件拷贝到新项目中。App.vue是vue项目的主文件，main.js是vue项目的入口文件。

接口调用之前一个后台管理的项目。

## 布局
创建完项目之后，我们对App.vue文件进行重新布局，使用弹性盒布局，vw+rem布局和媒体查询，媒体查询主要用于移动端竖屏，移动端横屏和pc端的适配。我们再从阿里iconfont图标库挑选图标，然后点击font class生成在线连接，引入到public静态资源文件中。
再抽离各个页面，有home首页，kind分类页面，cart购物车页面，user个人中心页面。

我们还可以通过transform样式描述，transition样式过渡和animation动画 由@keyframes来描述每一帧的样式来进行过渡动画的效果。

## Keep-alive
Keep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。
在App.js中用keepAlive标签包住router-view标签，不用缓存的组件不需要包。路由中的meta标签中记录keepAlive的属性为true。然后再router-view标签上加入$route.meta.keepAlive的判断来选择需要缓存的路由切换，这里用于分类，首页和详情页的切换，可以记录上一次点击的状态。如果有动画效果记得包住keep-alive。

## Vue-router
先在router/index.js中定义路由，给’/’定义一个路由重定向到首页，设置hash或者history路由模式，hash模式hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。，而histroy模式在刷新的时候会向通过history api，我们丢掉了丑陋的#，但是它也有个问题：不怕前进，不怕后退，就怕刷新，f5，（如果后端没有准备的话）,因为刷新是实实在在地去请求服务器的。
构建 SPA (单页应用) 时，我们用router-link声明式跳转，结合to属性进行页面的跳转，会默认生成a标签，我们使用tag属性生成目标标签，把 router-view 当做是一个容器，它渲染的组件是你使用 vue-router 指定的，用于渲染你指定路由对应的组件。这个项目的router-link都写在footer.vue文件中，也就是底部导航栏的跳转，用命名视图将其放入路由文件中。

## Vuex状态管理
vuex的就是vue中的状态管理模式，采用集中式管理组件的状态，虽然能管理组件的所有状态，但是我们通常不这么做，通常不同的视图需要用的同一个状态，不同视图的行为要变更同一状态的时候，我们就会去使用状态管理器。这里我们就要用到单向数据流理念的思想，什么是单向数据流呢，它其实就是一个单方向的运动，把所有组件都看成父组件给子组件传值的方式，子承父业。正因为组件之间传值都无法满足这个，所以要用vuex。 ​ 单一的数据源说的就是store，里面有state，getters，mutations，actions，我们项目足够大，我们需要用模块来划分状态管理器，用modules来组合。

1.state
单一状态，多个页面依赖于同一个状态。
2.getters
从store中的state中派生出一些状态，getters的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，可以认为是store的计算属性。
3.mutations
更改Vuex的store中的状态的唯一方法，触发store.commit方法。
4.actions
Action提交的是mutation，而不是直接变更状态。Action是处理异步操作的，或者是同时调用多个mutations是对其进行封装。
状态管理器处理异步操作有两个方法：
1.异步操作交给组件去做处理，我们直接在组件内部提交mutations，来改变我们的state。
2.直接在组件当中去触发action，action中的异步操作执行完毕之后，再去提交mutations从而再去修改state。
项目中登陆状态，购物车中的数量用到vuex。我们需要页面底部，购物车页面和详情页面都要共享商品的数量。在所有有用户信息的地方验证它的登陆状态。

## Axios
服务端通讯我们可以使用axios，它都是基于es6的promise封装的，支持浏览器和nodejs，能拦截请求和响应，自动转换json数据。
我们在vue.config.js中加入devServer.proxy用前端代理解决跨域问题。在api/index.js中统一封装的请求，用于暴露请求数据的函数，其中如果要传参的话，get请求中params要加{}，post请求不需要。
我们通过在utils/request中，引入axios，通过axios.create来创建request请求，通过process.env.NODE_ENV来判断开发模式还是线上模式，从而选择对应的url地址。

## Vant组件库
接着我们引入vant组件库，在babel.config.js中配置vant。

## 一、首页
首页由vant-swipe轮播图组件，自定义的nav导航栏组件和商品列表组成。在prolist.vue中构建商品的列表组件，这里我们通过在index.vue中的mouned钩子函数获取banner和pro数据，然后通过父传子传值的方式，prolist组件通过props接收index.vue传来的prolist数据，然后渲染到页面上。上拉加载功能，在list组件中设置默认不主动加载一次，开启加载，当获取数据时，先把结束加载，如果获取到的数据为空时，就结束下拉动作，有数据就把新的数据拼接到之前的prolist后面，本次加载结束，页码再加一。下拉刷新就是下拉只加载第一页的数据。回到顶部就是记录contentref的滚动高度，判断当高度大于300的时候，出现回到顶部的按钮，然后点击置0。

## 二、详情页
点击首页的商品时，通过动态路由，router.push编程式跳转值详情页，携带proid，在目标路由可以通过this.$route.params来获取proid，通过proid来渲染商品的其他信息。
我们在详情页面的时候点击加入购物车，接口先传入userid和proid判断该用户是否有这个商品，没有就新增商品，有就更新商品数量。

## 三、注册
先是输入手机号的页面，只有输入的手机号复合手机的正则时才能点击下一步，先调用检测手机号是否已经注册的接口，没有注册就加入数据库。然后跳转到获取手机验证码的页面，用计时器制作倒计时的效果，通过传入localstorage中的手机号调用发送验证码接口，然后在把tel和telcode传入调用验证验证码的接口，验证成功后可以点击下一步。再跳转到设置密码页面，通过右侧的眼睛可以显示和隐藏密码，当密码满足密码的正则可以点击下一步，并调用设置密码接口把tel和password传入数据库。

## 四、登录
登录页面可以通过左下角的切换密码登陆或者验证码登陆，分别调用不同的接口来验证。
我们使用token来验证登陆状态。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。所以我们在登陆成功后，后端接口生成一个token字符串，然后将token和userid返回至客户端，将token和userid保存在localstorage中，客户端只需要接收userid和token就可以判断用户的身份。
我们在后端也封装了token拦截器，内部用promise解决异步操作，让每次客户端进入接口的时候也要携带token才能数据库操作。
这里我们在客户端设置请求拦截器，所有请求都会将本地的token值放入http的header中传递到服务器，还添加了响应的拦截器，所有的接口返回先走响应拦截器，再执行下一步，响应token的有效性，获取响应的字段，如果code为10119，直接跳转到登陆页面。
五、购物车
该页面中我们通过userid调用购物车的数据接口，渲染数据，其中我们后端的接口使用了promise.all方法，promise.all将多个promise放在一起处理，能简化回调的处理，一个then回调拿到所有数据进行处理，也能一个catch回调捕获所有的异常，之所以用promise.all是因为我们既要通过userid查询cart集合中对应的购物车数据，然后遍历购物车数据，把其中通过proid查询商品详情的promise对象（因为每个sql方法都返回一个promise对象）放到一个数组中，通过promise.all来返回该用户的购物车中所有商品的相关信息，再遍历结果，每个商品是一个对象，把每个商品对象放到一个list数组中，再返回给客户端。
如果购物车没有数据，就给一个跳转到分类的按钮进行跳转。我们通过使用vant滑动单元格来达到向左删除的操作，调用删除接口同时在cartlist中删除该商品数据。通过cartlist.reduce方法累加商品的数量和总价放入计算属性中。如果修改商品的数量也要调用修改数量的接口，在购物车中加入一个flag属性用于判断商品选中的状态，当商品被选中时，设置状态为true，没有选中为false。然后再判断全选勾选框是否被选中，全选的v-model为checked，给复选框每个商品加一个点击事件，判断当前商品是否被选中，没有被选中全选框的checked为false，如果选中了再判断其余的其他商品是否被选中，用cartlist.every方法判断其余的商品的选中状态，只要有一个false就返回让checked为false，全为true即checked为true，全选框被选中。同时点击全选框如果被选中，所有商品的flag为true，否则为false。在mounted获取商品的数据时也要判断checked的状态，来实时获取列表状态，推算全选的默认值。当全选被选中时，调用更新当前购物车中每个商品的flag为true。更新单个商品的选中状态时，调用单个商品更新的接口。在购物车页面点击结算的时候，调用新增订单的接口。

## 六、订单
进入确认订单页面，不可轻易返回。
进入确认订单页面，需要两个数据请求，一个是默认地址，一个是订单的列表
没有默认地址弹窗显示去添加地址
多个店铺的订单，统一处理，靠时间。
我们通过time来判断多个店铺订单的唯一性，通过router.push携带time到order页面，通过传入userid和time来确定订单信息，判断有没有订单地址，没有订单地址就用默认地址，没有默认地址就调用增加地址的接口，然后跳转到新增地址页面，填写地址的相关信息，引入area.js添加选择地方的下拉框，点击确定到地址列表页面，默认选中默认地址，点击选中的地址，把选中的地址放到第一个，因为渲染地址列表是按地址的time来从大到小排序。然后跳转到订单页面。点击去结算的时候，就调用删除购物车数据和支付的接口，去支付按钮的事件中，可以根据购物车中数据的flag字段为true才能进入支付页面。

## 七、支付
点击去支付（微信支付），调用支付接口。拿到数据，跳转页面，生成支付的二维码，在支付页面展示。
要做微信支付，必须得有账号，要有账号，必须得有企业，得有营业执照，去 微信支付开发平台 申请开通微信支付（不同的微信支付方式都需要单独申请）
	后端需要配置用户支付结果的回调，回调的接口的 /wxpay/notify,在此接口中接收微信支付的结果，如果支付成功，通知前端页面，跳转至支付结果页面。
使用 socket 通讯（聊天）， 不要使用轮询（不知道有没有,就一直调用，知道接收到有了）。vue 中引入 vue-socket.io

后台项目添加常用属性标的配置文件,这些配置均由不需要更改，直接使用接口，如果自己想配置，先申请公司，然后申请微信支付功能。根据统一下单接口添加必须的属性，前端只需要 产品的描述 + 产品的订单id + 交易的金额。
微信支付API接口协议中包含字段nonce_str，主要保证签名不可预测。我们推荐生成随机数算法如下：调用随机数函数生成，将得到的值转换为字符串。
项目根目录下创建utils文件夹，在其下创建 tools.js，安装随机字符串模块。
签名生成的通用步骤如下：
	第一步，设所有发送或者接收到的数据为集合M，将集合M内非空参数值的参数按照参数名ASCII码从小到大排序（字典序），使用URL键值对的格式（即key1=value1&key2=value2…）拼接成字符串stringA。
第二步，在stringA最后拼接上key得到stringSignTemp字符串，并对stringSignTemp进行MD5运算，再将得到的字符串所有字符转换为大写，得到sign值signValue。

后端编写接口步骤：
1.整合数据
2.封装生成签名
3.调用方法getSign和getNoncestr
4.将必须的属性整合生成xml文件封装
5.使用axios封装数据请求的方法
6.接口调用统一下单接口
7.将xml文件转为js文件
8.接口调用xml转js，获取支付的url地址
9.url地址生成二维码

我对支付的理解：
有一次我跟我们后端去看，支付功能需要把所有参数转成对象，用object.keys()方法把对象的key值放进数组，再用sort方法把key值按照ACII码的首字母按从小到大的排序，用数组的value值找到对象的key值，从而带入对象的value值，我记得好像还要拼接一个key密钥，从而生成随机字符串的签名，这个签名的获取另我印象最深刻。

## 七、搜索
点击首页的搜索框，跳转到搜索页面，输入搜索内容，当点击搜索时，会先获取localstorage中的searchlist，如果没有就给一个空数组，如果有就将proid传入数组中，判断数组中是否有这个proid，有就先删除，然后用unshift方法插入数组头部，没有就用unshift方法插入数组头部，然后将searchlist设置进localstorage中。然后跳转到搜索的商品列表页，复用之前首页中的prolist组件，该页面可以根据价格和销量进行升序降序，还可以筛选价格区间的商品。

## 八、分类
左侧菜单栏先获取商品分类的接口数据，点击分类再获取对每个分类的品牌的接口数据，点击品牌时，通过router.push中’/kindlist/?’后拼接当前点击对应的商品分类和商品品牌，到kindlist页面通过this.$route.query进行解析商品分类和商品品牌，进行商品的查询。该页面也可以根据价格和销量进行升序降序，还可以筛选价格区间的商品。